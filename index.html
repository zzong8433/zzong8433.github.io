<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MoveFit Partners - Future of Fitness</title>
    <link href="https://fonts.googleapis.com/css2?family=Pretendard:wght@300;400;600;800&display=swap" rel="stylesheet">
    <style>
        /* * í†µí•© ìŠ¤íƒ€ì¼ ì‹œíŠ¸ 
         * Nexusì˜ 3D ë°°ê²½ ìŠ¤íƒ€ì¼ê³¼ MoveFitì˜ ë ˆì´ì•„ì›ƒ ìŠ¤íƒ€ì¼ì„ ë³‘í•©
         */

        /* í°íŠ¸ ì„¤ì • */
        @import url("https://fonts.cdnfonts.com/css/pp-neue-montreal");
        @font-face {
            font-family: "PPSupplyMono";
            src: url("https://assets.codepen.io/7558/PPSupplyMono-Regular.ttf") format("truetype");
            font-weight: normal; font-style: normal; font-display: swap;
        }

        :root {
            /* MoveFit Colors - Dark Mode Adaptation */
            --primary-color: #ffffff; /* í…ìŠ¤íŠ¸ëŠ” í™”ì´íŠ¸ë¡œ ë³€ê²½ */
            --accent-color: #e67e22; /* ì˜¤ë Œì§€ í¬ì¸íŠ¸ ìœ ì§€ */
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-main: #ffffff;
            --text-sub: #cccccc;
            
            /* Nexus Variables */
            --font-primary: "PP Neue Montreal", "Pretendard", sans-serif;
            --font-secondary: "PPSupplyMono", monospace;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Pretendard', var(--font-primary);
            color: var(--text-main);
            line-height: 1.6;
            word-break: keep-all;
            background-color: #050505; /* Fallback color */
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
        }

        /* --- 3D Background Canvas --- */
        #container {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 0;
            pointer-events: none; /* í´ë¦­ í†µê³¼ */
        }

        /* --- UI Controls (Optional, hiding for clean portfolio) --- */
        #ui-container { display: none; } 

        /* --- Content Wrapper (Floats above Canvas) --- */
        .content-wrapper {
            position: relative;
            z-index: 1; /* ìº”ë²„ìŠ¤ ìœ„ì— ë°°ì¹˜ */
            width: 100%;
        }

        .container { max-width: 100%; margin: 0 auto; }
        .inner { max-width: 800px; margin: 0 auto; padding: 0 20px; }

        /* 1. Hero Section */
        .hero { 
            /* ë°°ê²½ìƒ‰ ì œê±° (íˆ¬ëª…), 3D ë°°ê²½ì´ ë³´ì´ë„ë¡ */
            background-color: transparent; 
            color: #fff; 
            padding: 120px 0 80px; 
            text-align: center; 
            position: relative;
        }
        
        .hero h1 { 
            font-family: var(--font-primary);
            font-size: 3.5rem; 
            font-weight: 800; 
            margin-bottom: 15px;
            letter-spacing: -0.02em;
            line-height: 1.1;
            text-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        .hero p { 
            font-family: var(--font-secondary);
            font-size: 1rem; 
            color: var(--accent-color);
            margin-bottom: 40px; 
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .hero-img-placeholder {
            width: 100%;
            max-width: 800px;
            height: 400px;
            /* Glassmorphism */
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            margin: 0 auto;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            font-family: var(--font-secondary);
            font-size: 0.9rem;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }

        /* 2. Sections Generic */
        .section { padding: 100px 0; }
        .section-title { 
            text-align: center; 
            font-size: 2.5rem; 
            margin-bottom: 60px; 
            font-weight: 700;
            font-family: var(--font-primary);
        }

        /* 3. Benefits Grid */
        .benefit-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; text-align: center; }
        
        .benefit-card { 
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            padding: 40px 20px; 
            border-radius: 16px; 
            transition: transform 0.3s ease, background 0.3s ease;
        }
        
        .benefit-card:hover {
            transform: translateY(-10px);
            background: rgba(255,255,255,0.08);
            border-color: rgba(255,255,255,0.3);
        }

        .benefit-icon { font-size: 2.5rem; margin-bottom: 20px; display: block; }
        .benefit-card h3 { font-size: 1.3rem; margin-bottom: 15px; color: #fff; }
        .benefit-card p { font-size: 0.95rem; color: var(--text-sub); line-height: 1.6; }

        /* 4. Brand Mood */
        .brand-mood { position: relative; }
        .mood-img-placeholder {
            width: 100%;
            height: 400px;
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            margin-bottom: 40px;
            font-family: var(--font-secondary);
        }
        .mood-text { text-align: center; max-width: 600px; margin: 0 auto; }
        .mood-text strong { font-size: 1.4rem; color: #fff; display: block; margin-bottom: 20px; }
        .mood-text p { color: var(--text-sub); }

        /* 5. Apply CTA */
        .apply-section { padding-bottom: 150px; }
        .apply-box { 
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.02) 100%);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 60px 30px; 
            border-radius: 30px; 
            box-shadow: 0 20px 50px rgba(0,0,0,0.2); 
            text-align: center;
        }
        
        .btn-apply {
            display: inline-block;
            background-color: var(--accent-color);
            color: #fff;
            padding: 20px 60px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 50px;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            box-shadow: 0 10px 30px rgba(230, 126, 34, 0.3);
            margin-top: 30px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .btn-apply:hover { 
            transform: scale(1.05); 
            box-shadow: 0 15px 40px rgba(230, 126, 34, 0.5);
            background-color: #ff8c33;
        }

        footer {
            border-top: 1px solid var(--glass-border);
            padding: 40px 0;
            text-align: center;
            color: #666;
            font-family: var(--font-secondary);
            font-size: 0.8rem;
            position: relative;
            z-index: 10;
        }

        /* Mobile Response */
        @media (max-width: 768px) {
            .hero h1 { font-size: 2.2rem; }
            .benefit-grid { grid-template-columns: 1fr; }
            .hero-img-placeholder { height: 250px; }
            .section { padding: 60px 0; }
        }

        /* Overlay Texture (Dust) */
        body::after {
            content: "";
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-image: url("https://img.freepik.com/premium-photo/white-dust-scratches-black-background_279525-2.jpg?w=640");
            background-repeat: repeat;
            opacity: 0.15;
            mix-blend-mode: screen;
            pointer-events: none;
            z-index: 2;
        }
    </style>
</head>
<body>

    <div id="container"></div>

    <div id="ui-container"></div>

    <div class="content-wrapper">
        <header class="hero">
            <div class="inner">
                <p>WE ARE LOOKING FOR PARTNERS</p>
                <h1>MoveFitê³¼ í•¨ê»˜ ì„±ì¥í• <br>í¬ë¦¬ì—ì´í„°ë¥¼ ì°¾ìŠµë‹ˆë‹¤</h1>
                
                <div class="hero-img-placeholder">
                    [ë¸Œëœë“œ ë©”ì¸ ì˜ìƒ/ì´ë¯¸ì§€ ì˜ì—­]<br>
                    Fluid Dynamics Theme
                </div>
            </div>
        </header>

        <section class="section">
            <div class="inner">
                <h2 class="section-title">Partner Benefits</h2>
                <div class="benefit-grid">
                    <div class="benefit-card">
                        <span class="benefit-icon">ğŸ</span>
                        <h3>ì‹ ì œí’ˆ ë¬´ë£Œ ì œê³µ</h3>
                        <p>ë¬´ë¸Œí•ì˜ í”„ë¦¬ë¯¸ì—„ ë¼ì¸ì—… ì œí’ˆì„<br>ê°€ì¥ ë¨¼ì € ì²´í—˜í•´ë³´ì„¸ìš”.</p>
                    </div>
                    <div class="benefit-card">
                        <span class="benefit-icon">ğŸ’°</span>
                        <h3>íŒë§¤ ìˆ˜ìµ ì‰ì–´</h3>
                        <p>ì „ìš© ë§í¬ë¥¼ í†µí•œ êµ¬ë§¤ ë°œìƒ ì‹œ<br>ì—…ê³„ ìµœê³  ìˆ˜ì¤€ì˜ ì»¤ë¯¸ì…˜ ì œê³µ</p>
                    </div>
                    <div class="benefit-card">
                        <span class="benefit-icon">ğŸ“¢</span>
                        <h3>ê³µì‹ ì±„ë„ í™ë³´</h3>
                        <p>ë¬´ë¸Œí• ê³µì‹ ì¸ìŠ¤íƒ€ê·¸ë¨ ë° ì‚¬ì´íŠ¸ì—<br>íŒŒíŠ¸ë„ˆë‹˜ì˜ ì½˜í…ì¸ ê°€ ì†Œê°œë©ë‹ˆë‹¤.</p>
                    </div>
                </div>
            </div>
        </section>

        <section class="section brand-mood">
            <div class="inner">
                <h2 class="section-title">Who we want?</h2>
                
                <div class="mood-img-placeholder">
                    [íŒŒíŠ¸ë„ˆ í™œë™ ì˜ˆì‹œ ì´ë¯¸ì§€]<br>
                    Home Training Lifestyle
                </div>

                <div class="mood-text">
                    <p style="font-family: var(--font-secondary); color: var(--accent-color); margin-bottom: 10px;">CORE VALUE</p>
                    <strong>"ê±´ê°•í•œ ì—ë„ˆì§€ë¥¼ ë‚˜ëˆ„ëŠ” ì‚¬ëŒ"</strong>
                    <p>
                        íŒ”ë¡œì›Œ ìˆ˜ê°€ ë§ì§€ ì•Šì•„ë„ ê´œì°®ìŠµë‹ˆë‹¤.<br>
                        ìì‹ ë§Œì˜ ìš´ë™ ë£¨í‹´ì„ ì¦ê¸°ê³ , ì†”ì§í•œ ë¦¬ë·°ë¥¼ ë‚¨ê²¨ì£¼ì‹¤ ìˆ˜ ìˆëŠ” ë¶„.<br>
                        ë¬´ë¸Œí•ì˜ ê°€ì¹˜ë¥¼ í•¨ê»˜ ì•Œë¦´ ì—´ì •ì ì¸ íŒŒíŠ¸ë„ˆë¼ë©´ ëˆ„êµ¬ë‚˜ í™˜ì˜í•©ë‹ˆë‹¤.
                    </p>
                </div>
            </div>
        </section>

        <section class="section apply-section">
            <div class="inner">
                <div class="apply-box">
                    <h2 style="margin-bottom: 15px; color: #fff;">ì§€ê¸ˆ ë°”ë¡œ ì§€ì›í•˜ì„¸ìš”</h2>
                    <p style="margin-bottom: 30px; color: #ccc;">
                        ê°„ë‹¨í•œ ì •ë³´ë¥¼ ë‚¨ê²¨ì£¼ì‹œë©´ ë‹´ë‹¹ìê°€ ê²€í†  í›„<br>
                        3ì¼ ì´ë‚´ì— ê°œë³„ ì—°ë½ ë“œë¦½ë‹ˆë‹¤.
                    </p>
                    
                    <a href="https://forms.google.com/" target="_blank" class="btn-apply">
                        íŒŒíŠ¸ë„ˆ ì‹ ì²­í•˜ê¸° ğŸš€
                    </a>
                    
                    <p style="margin-top: 30px; font-size: 0.9rem; color: #666;">
                        *ë¬¸ì˜ì‚¬í•­: support@movefit.co.kr
                    </p>
                </div>
            </div>
        </section>

        <footer>
            <div class="inner">
                <p>&copy; 2025 MoveFit. All Rights Reserved.</p>
            </div>
        </footer>
    </div>

    <script type="module">
        import * as THREE from "https://esm.sh/three@0.178.0";
        import { Pane } from "https://cdn.skypack.dev/tweakpane@4.0.4";

        let scene, camera, renderer, material;
        let clock, mouse = { x: 0, y: 0 };
        let cursorSphere3D = new THREE.Vector3(0, 0, 0);
        let activeMerges = 0;
        let targetMousePosition = new THREE.Vector2(0.5, 0.5);
        let mousePosition = new THREE.Vector2(0.5, 0.5);
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        // Device detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        const isLowPowerDevice = isMobile || navigator.hardwareConcurrency <= 4;
        const devicePixelRatio = Math.min(window.devicePixelRatio || 1, isMobile ? 1.5 : 2);

        // Define Presets - We will use a modified "Cosmic/Minimal" blend for the background
        const bgPreset = {
            sphereCount: isMobile ? 3 : 6,
            ambientIntensity: 0.05,
            diffuseIntensity: 0.5,
            specularIntensity: 1.0,
            specularPower: 10,
            fresnelPower: 2.0,
            // Darker background to make text readable
            backgroundColor: new THREE.Color(0x050505),
            sphereColor: new THREE.Color(0x0a0a0a),
            // Orange/Blue tint to match MoveFit/Tech vibe
            lightColor: new THREE.Color(0xff8866), // Subtle orange tint
            lightPosition: new THREE.Vector3(1, 0.5, 0.8),
            smoothness: 0.4,
            contrast: 1.5,
            fogDensity: 0.1,
            cursorGlowIntensity: 0.6,
            cursorGlowRadius: 1.2,
            cursorGlowColor: new THREE.Color(0xff6644) // Orange glow
        };

        const settings = {
            ...bgPreset,
            fixedTopLeftRadius: 0.8,
            fixedBottomRightRadius: 0.9,
            smallTopLeftRadius: 0.3,
            smallBottomRightRadius: 0.35,
            cursorRadiusMin: 0.08,
            cursorRadiusMax: 0.15,
            animationSpeed: 0.4, // Slower for background
            movementScale: 1.0,
            mouseSmoothness: 0.08,
            mergeDistance: 1.5,
            mouseProximityEffect: true,
            minMovementScale: 0.3,
            maxMovementScale: 1.0
        };

        init();
        animate();

        function init() {
            const container = document.getElementById("container");
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
            camera.position.z = 1;
            clock = new THREE.Clock();

            renderer = new THREE.WebGLRenderer({
                antialias: !isMobile && !isLowPowerDevice,
                alpha: true,
                powerPreference: "high-performance",
                preserveDrawingBuffer: false,
                premultipliedAlpha: false
            });

            const pixelRatio = Math.min(devicePixelRatio, isMobile ? 1.5 : 2);
            renderer.setPixelRatio(pixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            renderer.outputColorSpace = THREE.SRGBColorSpace;

            const canvas = renderer.domElement;
            canvas.style.cssText = `
                position: fixed !important; top: 0 !important; left: 0 !important;
                width: 100vw !important; height: 100vh !important;
                z-index: 0 !important; display: block !important;
            `;
            container.appendChild(canvas);

            // Shader Material Setup (Same as provided code)
            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    uActualResolution: { value: new THREE.Vector2(window.innerWidth * pixelRatio, window.innerHeight * pixelRatio) },
                    uPixelRatio: { value: pixelRatio },
                    uMousePosition: { value: new THREE.Vector2(0.5, 0.5) },
                    uCursorSphere: { value: new THREE.Vector3(0, 0, 0) },
                    uCursorRadius: { value: settings.cursorRadiusMin },
                    uSphereCount: { value: settings.sphereCount },
                    uFixedTopLeftRadius: { value: settings.fixedTopLeftRadius },
                    uFixedBottomRightRadius: { value: settings.fixedBottomRightRadius },
                    uSmallTopLeftRadius: { value: settings.smallTopLeftRadius },
                    uSmallBottomRightRadius: { value: settings.smallBottomRightRadius },
                    uMergeDistance: { value: settings.mergeDistance },
                    uSmoothness: { value: settings.smoothness },
                    uAmbientIntensity: { value: settings.ambientIntensity },
                    uDiffuseIntensity: { value: settings.diffuseIntensity },
                    uSpecularIntensity: { value: settings.specularIntensity },
                    uSpecularPower: { value: settings.specularPower },
                    uFresnelPower: { value: settings.fresnelPower },
                    uBackgroundColor: { value: settings.backgroundColor },
                    uSphereColor: { value: settings.sphereColor },
                    uLightColor: { value: settings.lightColor },
                    uLightPosition: { value: settings.lightPosition },
                    uContrast: { value: settings.contrast },
                    uFogDensity: { value: settings.fogDensity },
                    uAnimationSpeed: { value: settings.animationSpeed },
                    uMovementScale: { value: settings.movementScale },
                    uMouseProximityEffect: { value: settings.mouseProximityEffect },
                    uMinMovementScale: { value: settings.minMovementScale },
                    uMaxMovementScale: { value: settings.maxMovementScale },
                    uCursorGlowIntensity: { value: settings.cursorGlowIntensity },
                    uCursorGlowRadius: { value: settings.cursorGlowRadius },
                    uCursorGlowColor: { value: settings.cursorGlowColor },
                    uIsSafari: { value: isSafari ? 1.0 : 0.0 },
                    uIsMobile: { value: isMobile ? 1.0 : 0.0 },
                    uIsLowPower: { value: isLowPowerDevice ? 1.0 : 0.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
                `,
                fragmentShader: `
                    precision highp float;
                    uniform float uTime;
                    uniform vec2 uResolution;
                    uniform vec2 uActualResolution;
                    uniform vec2 uMousePosition;
                    uniform vec3 uCursorSphere;
                    uniform float uCursorRadius;
                    uniform int uSphereCount;
                    uniform float uFixedTopLeftRadius;
                    uniform float uFixedBottomRightRadius;
                    uniform float uSmallTopLeftRadius;
                    uniform float uSmallBottomRightRadius;
                    uniform float uMergeDistance;
                    uniform float uSmoothness;
                    uniform float uAmbientIntensity;
                    uniform float uDiffuseIntensity;
                    uniform float uSpecularIntensity;
                    uniform float uSpecularPower;
                    uniform float uFresnelPower;
                    uniform vec3 uBackgroundColor;
                    uniform vec3 uSphereColor;
                    uniform vec3 uLightColor;
                    uniform vec3 uLightPosition;
                    uniform float uContrast;
                    uniform float uFogDensity;
                    uniform float uAnimationSpeed;
                    uniform float uMovementScale;
                    uniform bool uMouseProximityEffect;
                    uniform float uMinMovementScale;
                    uniform float uMaxMovementScale;
                    uniform float uCursorGlowIntensity;
                    uniform float uCursorGlowRadius;
                    uniform vec3 uCursorGlowColor;
                    uniform float uIsMobile;
                    
                    const float PI = 3.14159265359;
                    const float EPSILON = 0.001;
                    const float MAX_DIST = 100.0;
                    
                    float smin(float a, float b, float k) {
                        float h = max(k - abs(a - b), 0.0) / k;
                        return min(a, b) - h * h * k * 0.25;
                    }
                    float sdSphere(vec3 p, float r) { return length(p) - r; }
                    vec3 screenToWorld(vec2 normalizedPos) {
                        vec2 uv = normalizedPos * 2.0 - 1.0;
                        uv.x *= uResolution.x / uResolution.y;
                        return vec3(uv * 2.0, 0.0);
                    }
                    float getDistanceToCenter(vec2 pos) { return smoothstep(0.0, 1.0, length(pos - vec2(0.5)) * 2.0); }
                    
                    float sceneSDF(vec3 pos) {
                        float result = MAX_DIST;
                        vec3 topLeftPos = screenToWorld(vec2(0.08, 0.92));
                        float topLeft = sdSphere(pos - topLeftPos, uFixedTopLeftRadius);
                        vec3 smallTopLeftPos = screenToWorld(vec2(0.25, 0.72));
                        float smallTopLeft = sdSphere(pos - smallTopLeftPos, uSmallTopLeftRadius);
                        vec3 bottomRightPos = screenToWorld(vec2(0.92, 0.08));
                        float bottomRight = sdSphere(pos - bottomRightPos, uFixedBottomRightRadius);
                        vec3 smallBottomRightPos = screenToWorld(vec2(0.72, 0.25));
                        float smallBottomRight = sdSphere(pos - smallBottomRightPos, uSmallBottomRightRadius);
                        
                        float t = uTime * uAnimationSpeed;
                        float dynamicMovementScale = uMovementScale;
                        if (uMouseProximityEffect) {
                            float mixFactor = smoothstep(0.0, 1.0, getDistanceToCenter(uMousePosition));
                            dynamicMovementScale = mix(uMinMovementScale, uMaxMovementScale, mixFactor);
                        }
                        
                        for (int i = 0; i < 10; i++) {
                            if (i >= uSphereCount) break;
                            float fi = float(i);
                            float speed = 0.4 + fi * 0.12;
                            float radius = 0.12 + mod(fi, 3.0) * 0.06;
                            float orbitRadius = (0.3 + mod(fi, 3.0) * 0.15) * dynamicMovementScale;
                            float phaseOffset = fi * PI * 0.35;
                            vec3 offset = vec3(
                                sin(t * speed + phaseOffset) * orbitRadius * 0.8,
                                cos(t * speed * 0.85 + phaseOffset * 1.3) * orbitRadius * 0.6,
                                sin(t * speed * 0.5 + phaseOffset) * 0.3
                            );
                            
                            vec3 toCursor = uCursorSphere - offset;
                            float cursorDist = length(toCursor);
                            if (cursorDist < uMergeDistance) {
                                float attraction = (1.0 - cursorDist / uMergeDistance) * 0.3;
                                offset += normalize(toCursor) * attraction;
                            }
                            
                            float movingSphere = sdSphere(pos - offset, radius);
                            float blend = 0.05;
                            if (cursorDist < uMergeDistance) {
                                float influence = 1.0 - (cursorDist / uMergeDistance);
                                blend = mix(0.05, uSmoothness, influence * influence * influence);
                            }
                            result = smin(result, movingSphere, blend);
                        }
                        
                        float cursorBall = sdSphere(pos - uCursorSphere, uCursorRadius);
                        float topLeftGroup = smin(topLeft, smallTopLeft, 0.4);
                        float bottomRightGroup = smin(bottomRight, smallBottomRight, 0.4);
                        result = smin(result, topLeftGroup, 0.3);
                        result = smin(result, bottomRightGroup, 0.3);
                        result = smin(result, cursorBall, uSmoothness);
                        return result;
                    }
                    
                    vec3 calcNormal(vec3 p) {
                        float eps = 0.001;
                        return normalize(vec3(
                            sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),
                            sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),
                            sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))
                        ));
                    }
                    
                    float rayMarch(vec3 ro, vec3 rd) {
                        float t = 0.0;
                        for (int i = 0; i < 48; i++) {
                            if (t > 5.0) break;
                            float d = sceneSDF(ro + rd * t);
                            if (d < 0.001) return t;
                            t += d * 0.9;
                        }
                        return -1.0;
                    }
                    
                    vec3 lighting(vec3 p, vec3 rd) {
                        vec3 normal = calcNormal(p);
                        vec3 viewDir = -rd;
                        vec3 lightDir = normalize(uLightPosition);
                        
                        float diff = max(dot(normal, lightDir), 0.0);
                        vec3 reflectDir = reflect(-lightDir, normal);
                        float spec = pow(max(dot(viewDir, reflectDir), 0.0), uSpecularPower);
                        float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), uFresnelPower);
                        
                        vec3 ambient = uLightColor * uAmbientIntensity;
                        vec3 diffuse = uLightColor * diff * uDiffuseIntensity;
                        vec3 specular = uLightColor * spec * uSpecularIntensity * fresnel;
                        vec3 fresnelRim = uLightColor * fresnel * 0.4;
                        
                        return uSphereColor + ambient + diffuse + specular + fresnelRim;
                    }
                    
                    void main() {
                        vec2 uv = (gl_FragCoord.xy * 2.0 - uActualResolution.xy) / uActualResolution.xy;
                        uv.x *= uResolution.x / uResolution.y;
                        vec3 ro = vec3(uv * 2.0, -1.0);
                        vec3 rd = vec3(0.0, 0.0, 1.0);
                        
                        float t = rayMarch(ro, rd);
                        
                        vec3 color = uBackgroundColor;
                        float cursorGlow = 0.0;
                        float dist = length(ro.xy - uCursorSphere.xy);
                        float glow = 1.0 - smoothstep(0.0, uCursorGlowRadius, dist);
                        cursorGlow = pow(glow, 2.0) * uCursorGlowIntensity;
                        
                        if (t > 0.0) {
                            vec3 p = ro + rd * t;
                            color = lighting(p, rd);
                            float fogAmount = 1.0 - exp(-t * uFogDensity);
                            color = mix(color, uBackgroundColor, fogAmount * 0.3);
                            color += uCursorGlowColor * cursorGlow * 0.3;
                            gl_FragColor = vec4(color, 1.0);
                        } else {
                            if (cursorGlow > 0.01) {
                                gl_FragColor = vec4(uCursorGlowColor, cursorGlow * 0.8);
                            } else {
                                gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
                            }
                        }
                    }
                `,
                transparent: true
            });

            const geometry = new THREE.PlaneGeometry(2, 2);
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            
            setupEventListeners();
            onPointerMove({ clientX: window.innerWidth / 2, clientY: window.innerHeight / 2 });
        }

        function setupEventListeners() {
            window.addEventListener("mousemove", onPointerMove, { passive: true });
            window.addEventListener("touchstart", (e) => { e.preventDefault(); if(e.touches.length) onPointerMove(e.touches[0]); }, { passive: false });
            window.addEventListener("touchmove", (e) => { e.preventDefault(); if(e.touches.length) onPointerMove(e.touches[0]); }, { passive: false });
            window.addEventListener("resize", onWindowResize, { passive: true });
        }

        function onPointerMove(event) {
            targetMousePosition.x = event.clientX / window.innerWidth;
            targetMousePosition.y = 1.0 - event.clientY / window.innerHeight;
            
            const aspect = window.innerWidth / window.innerHeight;
            const uv_x = targetMousePosition.x * 2.0 - 1.0;
            const uv_y = targetMousePosition.y * 2.0 - 1.0;
            cursorSphere3D.set(uv_x * aspect * 2.0, uv_y * 2.0, 0.0);
            
            material.uniforms.uCursorSphere.value.copy(cursorSphere3D);
        }

        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const pixelRatio = Math.min(devicePixelRatio, isMobile ? 1.5 : 2);
            
            renderer.setSize(width, height);
            renderer.setPixelRatio(pixelRatio);
            
            material.uniforms.uResolution.value.set(width, height);
            material.uniforms.uActualResolution.value.set(width * pixelRatio, height * pixelRatio);
        }

        function animate() {
            requestAnimationFrame(animate);
            mousePosition.x += (targetMousePosition.x - mousePosition.x) * settings.mouseSmoothness;
            mousePosition.y += (targetMousePosition.y - mousePosition.y) * settings.mouseSmoothness;
            
            material.uniforms.uTime.value = clock.getElapsedTime();
            material.uniforms.uMousePosition.value = mousePosition;
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
